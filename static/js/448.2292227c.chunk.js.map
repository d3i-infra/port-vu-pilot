{"version":3,"file":"static/js/448.2292227c.chunk.js","mappings":"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","sources":["framework/visualisation/react/ui/workers/visualizationDataFunctions/util.ts","framework/visualisation/react/ui/workers/visualizationDataFunctions/prepareChartData.ts","framework/visualisation/react/ui/workers/visualizationDataFunctions/prepareTextData.ts","framework/visualisation/react/ui/workers/visualizationDataWorker.ts"],"sourcesContent":["import { PropsUITable, TableContext } from '../../../../../types/elements'\nimport { DateFormat } from '../../../../../types/visualizations'\n\nexport function formatDate(\n  dateString: string[],\n  format: DateFormat,\n  minValues: number = 10\n): [string[], Record<string, number> | null] {\n  let formattedDate: string[] = dateString\n  const dateNumbers = dateString.map((date) => new Date(date).getTime())\n  let domain: [number, number] | null = null\n  let formatter: (date: Date) => string = (date) => date.toISOString()\n\n  if (format === 'auto') format = autoFormatDate(dateNumbers, minValues)\n\n  if (format === 'year') formatter = (date) => date.getFullYear().toString()\n\n  if (format === 'quarter') {\n    formatter = (date) => {\n      const year = date.getFullYear().toString()\n      const quarter = Math.floor(date.getMonth() / 3) + 1\n      return `${year}-Q${quarter}`\n    }\n  }\n\n  if (format === 'month') {\n    formatter = (date) => {\n      const year = date.getFullYear().toString()\n      const month = date.toLocaleString('default', { month: 'short' })\n      return `${year}-${month}`\n    }\n  }\n\n  if (format === 'day') {\n    formatter = (date) => {\n      const year = date.getFullYear().toString()\n      const month = date.toLocaleString('default', { month: 'short' })\n      const day = date.getDate().toString()\n      return `${year}-${month}-${day}`\n    }\n  }\n\n  if (format === 'hour') {\n    formatter = (date) => {\n      const year = date.getFullYear().toString()\n      const month = date.toLocaleString('default', { month: 'short' })\n      const day = date.getDate().toString()\n      const hour = date.toISOString().split('T')[1].split(':')[0]\n      return `${year}-${month}-${day} ${hour}:00`\n    }\n  }\n\n  if (format === 'month_cycle') {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat('default', { month: 'long' })\n      return intlFormatter.format(date)\n    }\n    // can be any year, starting at january\n    domain = [new Date('2000-01-01').getTime(), new Date('2001-01-01').getTime()]\n  }\n  if (format === 'weekday_cycle') {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat('default', { weekday: 'long' })\n      return intlFormatter.format(date)\n    }\n    // can be any full week, starting at monday\n    domain = [new Date('2023-11-06').getTime(), new Date('2023-11-13').getTime()]\n  }\n  if (format === 'hour_cycle') {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat('default', { hour: 'numeric', hour12: false })\n      return intlFormatter.format(date)\n    }\n    // can be any day, starting at midnight\n    domain = [new Date('2000-01-01').getTime(), new Date('2000-01-02').getTime()]\n  }\n\n  formattedDate = dateNumbers.map((date) => formatter(new Date(date)))\n  if (domain == null) domain = getDomain(dateNumbers)\n  const sortableDate: Record<string, number> | null = createSortable(domain, format, formatter)\n\n  return [formattedDate, sortableDate]\n}\n\nfunction autoFormatDate(dateNumbers: number[], minValues: number): DateFormat {\n  const [minTime, maxTime] = getDomain(dateNumbers)\n\n  let autoFormat: DateFormat = 'hour'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * minValues) autoFormat = 'day'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * minValues) autoFormat = 'month'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * 3 * minValues) autoFormat = 'quarter'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 365 * minValues) autoFormat = 'year'\n\n  return autoFormat\n}\n\nfunction createSortable(\n  domain: [number, number],\n  interval: string,\n  formatter: (date: Date) => string\n): Record<string, number> | null {\n  // creates a map of datestrings to sortby numbers. Also includes intervalls, so that\n  // addZeroes can be used.\n  const sortable: Record<string, number> = {}\n  const [minTime, maxTime] = domain\n\n  // intervalnumbers don't need to be exact. Just small enough that they never\n  // skip over an interval (e.g., month should be shortest possible month).\n  // Duplicate dates are ignored in set\n  let intervalNumber: number = 0\n  if (interval === 'year') intervalNumber = 1000 * 60 * 60 * 24 * 364\n  if (interval === 'quarter') intervalNumber = 1000 * 60 * 60 * 24 * 28 * 3\n  if (['month', 'month_cycle'].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24 * 28\n  if (['day', 'weekday_cycle'].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24\n  if (['hour', 'hour_cycle'].includes(interval)) intervalNumber = 1000 * 60 * 60\n\n  if (intervalNumber > 0) {\n    for (let i = minTime; i <= maxTime; i += intervalNumber) {\n      const date = new Date(i)\n      const datestring = formatter(date)\n      if (sortable[datestring] !== undefined) continue\n      sortable[datestring] = i\n    }\n  }\n\n  return sortable\n}\n\nfunction getDomain(numbers: number[]): [number, number] {\n  let min = numbers[0]\n  let max = numbers[0]\n  numbers.forEach((nr) => {\n    if (nr < min) min = nr\n    if (nr > max) max = nr\n  })\n  return [min, max]\n}\n\nexport function tokenize(text: string): string[] {\n  const tokens = text.split(' ')\n  return tokens.filter((token) => /\\p{L}/giu.test(token)) // only tokens with word characters\n}\n\nexport function getTableColumn(table: PropsUITable & TableContext, column: string): string[] {\n  const columnIndex = table.head.cells.findIndex((cell) => cell === column)\n  if (columnIndex < 0) throw new Error(`column ${table.id}.${column} not found`)\n  return table.body.rows.map((row) => row.cells[columnIndex])\n}\n\nexport function rescaleToRange(\n  value: number,\n  min: number,\n  max: number,\n  newMin: number,\n  newMax: number\n): number {\n  let scaled = (value - min) / (max - min)\n  scaled = scaled || 0 // prevent NaN\n  return scaled * (newMax - newMin) + newMin\n}\n\nexport function extractUrlDomain(x: string): string {\n  let domain\n  try {\n    const url = new URL(x)\n    domain = url.hostname.replace(/^www\\./, '').replace(/^m\\./, '')\n  } catch (_) {\n    domain = x\n  }\n  return domain.trim()\n}\n","import { formatDate, getTableColumn } from './util'\nimport { PropsUITable, TableContext } from '../../../../../types/elements'\nimport {\n  TickerFormat,\n  ChartVisualizationData,\n  ChartVisualization\n} from '../../../../../types/visualizations'\n\nexport async function prepareChartData(\n  table: PropsUITable & TableContext,\n  visualization: ChartVisualization\n): Promise<ChartVisualizationData> {\n  if (table.body.rows.length === 0) return emptyVisualizationData(visualization)\n\n  const aggregate = aggregateData(table, visualization)\n  return createVisualizationData(visualization, aggregate)\n}\n\nfunction createVisualizationData(\n  visualization: ChartVisualization,\n  aggregate: Record<string, PrepareAggregatedData>\n): ChartVisualizationData {\n  const visualizationData = emptyVisualizationData(visualization)\n\n  for (const aggdata of Object.values(aggregate)) {\n    for (const group of Object.keys(aggdata.values)) {\n      if (visualizationData.yKeys[group] === undefined) {\n        visualizationData.yKeys[group] = {\n          label: group,\n          secondAxis: aggdata.secondAxis,\n          tickerFormat: aggdata.tickerFormat\n        }\n      }\n    }\n  }\n\n  visualizationData.data = Object.values(aggregate)\n    .sort((a: any, b: any) => (a.sortBy < b.sortBy ? -1 : b.sortBy < a.sortBy ? 1 : 0))\n    .map((d) => {\n      for (const key of Object.keys(d.values)) d.values[key] = Math.round(d.values[key] * 100) / 100\n\n      return {\n        ...d.values,\n        __x: d.xValue,\n        __rowIds: d.rowIds,\n        __sortBy: d.sortBy\n      }\n    })\n\n  return visualizationData\n}\n\nfunction emptyVisualizationData(visualization: ChartVisualization): ChartVisualizationData {\n  return {\n    type: visualization.type,\n    xKey: {\n      label:\n        visualization.group.label !== undefined\n          ? visualization.group.label\n          : visualization.group.column\n    },\n    yKeys: {},\n    data: []\n  }\n}\n\nfunction aggregateData(\n  table: PropsUITable & TableContext,\n  visualization: ChartVisualization\n): Record<string, PrepareAggregatedData> {\n  const aggregate: Record<string, PrepareAggregatedData> = {}\n\n  const { groupBy, xSortable } = prepareX(table, visualization)\n  const rowIds = table.body.rows.map((row) => row.id)\n  const xLabel =\n    visualization.group.label !== undefined ? visualization.group.label : visualization.group.column\n\n  const anyAddZeroes = visualization.values.some((value) => value.addZeroes === true)\n  if (anyAddZeroes && xSortable != null) {\n    for (const [uniqueValue, sortby] of Object.entries(xSortable)) {\n      aggregate[uniqueValue] = {\n        sortBy: sortby,\n        rowIds: {},\n        xLabel,\n        xValue: uniqueValue,\n        values: {},\n        secondAxis: false,\n        tickerFormat: 'default'\n      }\n    }\n  }\n\n  for (const value of visualization.values) {\n    // loop over all y values\n\n    const aggFun = value.aggregate !== undefined ? value.aggregate : 'count'\n    let tickerFormat: TickerFormat = 'default'\n    if (aggFun === 'pct' || aggFun === 'count_pct') tickerFormat = 'percent'\n\n    const yValues = getTableColumn(table, value.column)\n    if (yValues.length === 0) throw new Error(`Y column ${table.id}.${value.column} not found`)\n\n    // If group_by column is specified, the columns in the aggregated data will be the unique group_by columns\n    const yGroup = value.group_by !== undefined ? getTableColumn(table, value.group_by) : null\n\n    // if missing values should be treated as zero, we need to add the missing values after knowing all groups\n    const addZeroes = value.addZeroes ?? false\n    const groupSummary: Record<string, { n: number; sum: number }> = {}\n\n    for (let i = 0; i < rowIds.length; i++) {\n      // loop over rows of table\n      const xValue = groupBy[i]\n\n      if (visualization.group.range !== undefined) {\n        if (\n          Number(xValue) < visualization.group.range[0] ||\n          Number(xValue) > visualization.group.range[1]\n        ) {\n          continue\n        }\n      }\n\n      // SHOULD GROUP BE IGNORED IF NOT IN group.levels? MAYBE NOT, BECAUSE\n      // THIS COULD HARM INFORMED CONSENT IF THE RESEARCHER IS UNAWARE OF CERTAIN GROUPS\n      // if (visualization.group.levels !== undefined) {\n      //   // formatLevels has xSortable < 0 if no match with levels\n      //   if (xSortable !== null && xSortable[i] < 0) continue\n      // }\n\n      const yValue = yValues[i]\n      const label = value.label !== undefined ? value.label : value.column\n      const group = yGroup != null ? yGroup[i] : label\n\n      const sortBy = xSortable != null ? xSortable[xValue] : groupBy[i]\n\n      // calculate group summary statistics. This is used for the mean, pct and count_pct aggregations\n      if (groupSummary[group] === undefined) groupSummary[group] = { n: 0, sum: 0 }\n      if (aggFun === 'count_pct' || aggFun === 'mean') groupSummary[group].n += 1\n      if (aggFun === 'pct') groupSummary[group].sum += Number(yValue) ?? 0\n\n      if (aggregate[xValue] === undefined) {\n        aggregate[xValue] = {\n          sortBy: sortBy,\n          rowIds: {},\n          xLabel,\n          xValue: String(xValue),\n          values: {},\n          secondAxis: value.secondAxis,\n          tickerFormat\n        }\n      }\n      if (aggregate[xValue].rowIds[group] === undefined) aggregate[xValue].rowIds[group] = []\n      aggregate[xValue].rowIds[group].push(rowIds[i])\n\n      if (aggregate[xValue].values[group] === undefined) aggregate[xValue].values[group] = 0\n      if (aggFun === 'count' || aggFun === 'count_pct') aggregate[xValue].values[group] += 1\n      if (aggFun === 'sum' || aggFun === 'mean' || aggFun === 'pct') {\n        aggregate[xValue].values[group] += Number(yValue) ?? 0\n      }\n    }\n\n    // use groupSummary to calculate the mean, pct and count_pct aggregations\n    Object.keys(groupSummary).forEach((group) => {\n      for (const xValue of Object.keys(aggregate)) {\n        if (aggregate[xValue].values[group] === undefined) {\n          if (addZeroes) aggregate[xValue].values[group] = 0\n          else continue\n        }\n        if (aggFun === 'mean') {\n          aggregate[xValue].values[group] =\n            Number(aggregate[xValue].values[group]) / groupSummary[group].n\n        }\n        if (aggFun === 'count_pct') {\n          aggregate[xValue].values[group] =\n            (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].n\n        }\n        if (aggFun === 'pct') {\n          aggregate[xValue].values[group] =\n            (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].sum\n        }\n      }\n    })\n  }\n\n  console.log(aggregate)\n  return aggregate\n}\n\nfunction prepareX(\n  table: PropsUITable & TableContext,\n  visualization: ChartVisualization\n): { groupBy: string[]; xSortable: Record<string, string | number> | null } {\n  let groupBy = getTableColumn(table, visualization.group.column)\n  if (groupBy.length === 0) {\n    throw new Error(`X column ${table.id}.${visualization.group.column} not found`)\n  }\n  // let xSortable: Array<string | number> | null = null // separate variable allows using epoch time for sorting dates\n  let xSortable: Record<string, string | number> | null = null // map x values to sortable values\n\n  // ADD CODE TO TRANSFORM TO DATE, BUT THEN ALSO KEEP AN INDEX BASED ON THE DATE ORDER\n  if (visualization.group.dateFormat !== undefined) {\n    ;[groupBy, xSortable] = formatDate(groupBy, visualization.group.dateFormat)\n  }\n\n  if (visualization.group.levels !== undefined) {\n    xSortable = {}\n\n    for (let i = 0; i < visualization.group.levels.length; i++) {\n      const level = visualization.group.levels[i]\n      xSortable[level] = i\n    }\n  }\n\n  return { groupBy, xSortable }\n}\n\nexport interface PrepareAggregatedData {\n  xLabel: string\n  xValue: string\n  values: Record<string, number>\n  rowIds: Record<string, string[]>\n  sortBy: number | string\n  secondAxis?: boolean\n  tickerFormat?: TickerFormat\n}\n","import { extractUrlDomain, getTableColumn, rescaleToRange, tokenize } from './util'\nimport { PropsUITable, TableContext } from '../../../../../types/elements'\nimport {\n  TextVisualizationData,\n  TextVisualization,\n  ScoredTerm\n} from '../../../../../types/visualizations'\n\ninterface VocabularyStats {\n  value: number\n  docFreq: number\n}\n\nexport async function prepareTextData (\n  table: PropsUITable & TableContext,\n  visualization: TextVisualization\n): Promise<TextVisualizationData> {\n  const visualizationData: TextVisualizationData = {\n    type: visualization.type,\n    topTerms: []\n  }\n\n  if (table.body.rows.length === 0) return visualizationData\n\n  const texts = getTableColumn(table, visualization.textColumn)\n  const values =\n    visualization.valueColumn != null ? getTableColumn(table, visualization.valueColumn) : null\n\n  const vocabulary = getVocabulary(texts, values, visualization)\n  visualizationData.topTerms = getTopTerms(vocabulary, texts.length, 200)\n\n  return visualizationData\n}\n\nfunction getVocabulary (\n  texts: string[],\n  values: string[] | null,\n  visualization: TextVisualization\n): Record<string, VocabularyStats> {\n  const vocabulary: Record<string, VocabularyStats> = {}\n\n  for (let i = 0; i < texts.length; i++) {\n    if (texts?.[i] == null) continue\n    const text = texts[i]\n    const tokens =\n      visualization.tokenize != null && visualization.tokenize ? tokenize(text) : [text]\n\n    const seen = new Set<string>()\n    for (let token of tokens) {\n      if (visualization.extract === 'url_domain') token = extractUrlDomain(token)\n      if (vocabulary[token] === undefined) vocabulary[token] = { value: 0, docFreq: 0 }\n      if (!seen.has(token)) {\n        vocabulary[token].docFreq += 1\n        seen.add(token)\n      }\n\n      const v = (values != null) ? Number(values[i]) ?? 1 : 1\n      if (!isNaN(v)) vocabulary[token].value += v\n    }\n  }\n  return vocabulary\n}\n\nfunction getTopTerms (\n  vocabulary: Record<string, VocabularyStats>,\n  nDocs: number,\n  topTerms: number\n): ScoredTerm[] {\n  return Object.entries(vocabulary)\n    .map(([text, stats]) => {\n      const tf = stats.value\n      const idf = Math.log(nDocs / stats.docFreq)\n      return { text, value: stats.value, importance: tf * idf }\n    })\n    .sort((a, b) => b.importance - a.importance)\n    .slice(0, topTerms)\n}\n","import { PropsUITable, TableContext, TableWithContext } from '../../../../types/elements'\nimport {\n  ChartVisualization,\n  TextVisualization,\n  VisualizationType,\n  VisualizationData\n} from '../../../../types/visualizations'\nimport { prepareChartData } from './visualizationDataFunctions/prepareChartData'\nimport { prepareTextData } from './visualizationDataFunctions/prepareTextData'\n\ninterface Input {\n  table: TableWithContext\n  visualization: VisualizationType\n}\n\nself.onmessage = (e: MessageEvent<Input>) => {\n  createVisualizationData(e.data.table, e.data.visualization)\n    .then((visualizationData) => {\n      self.postMessage({ status: 'success', visualizationData })\n    })\n    .catch((error) => {\n      console.error(error)\n      self.postMessage({ status: 'error', visualizationData: undefined })\n    })\n}\n\nasync function createVisualizationData (\n  table: PropsUITable & TableContext,\n  visualization: VisualizationType\n): Promise<VisualizationData> {\n  if (table === undefined || visualization === undefined) throw new Error('Table and visualization are required')\n\n  if (['line', 'bar', 'area'].includes(visualization.type)) { return await prepareChartData(table, visualization as ChartVisualization) }\n\n  if (['wordcloud'].includes(visualization.type)) { return await prepareTextData(table, visualization as TextVisualization) }\n\n  throw new Error(`Visualization type ${visualization.type} not supported`)\n}\n"],"names":["formatDate","dateString","format","minValues","arguments","length","undefined","formattedDate","dateNumbers","map","date","Date","getTime","domain","formatter","toISOString","minTime","maxTime","getDomain","autoFormat","autoFormatDate","getFullYear","toString","year","quarter","Math","floor","getMonth","concat","month","toLocaleString","day","getDate","hour","split","Intl","DateTimeFormat","weekday","hour12","sortableDate","interval","sortable","intervalNumber","includes","i","datestring","createSortable","numbers","min","max","forEach","nr","tokenize","text","filter","token","test","getTableColumn","table","column","columnIndex","head","cells","findIndex","cell","Error","id","body","rows","row","extractUrlDomain","x","URL","hostname","replace","_","trim","async","prepareChartData","visualization","emptyVisualizationData","aggregate","groupBy","xSortable","group","dateFormat","levels","prepareX","rowIds","xLabel","label","anyAddZeroes","values","some","value","addZeroes","uniqueValue","sortby","Object","entries","sortBy","xValue","secondAxis","tickerFormat","_value$addZeroes","aggFun","yValues","yGroup","group_by","groupSummary","_Number","range","Number","yValue","_Number2","n","sum","String","push","keys","console","log","aggregateData","visualizationData","aggdata","yKeys","data","sort","a","b","d","key","round","__x","__rowIds","__sortBy","createVisualizationData","type","xKey","prepareTextData","topTerms","texts","textColumn","vocabulary","tokens","seen","Set","extract","docFreq","has","add","v","isNaN","getVocabulary","valueColumn","nDocs","_ref","stats","tf","idf","importance","slice","getTopTerms","self","onmessage","e","then","postMessage","status","catch","error"],"sourceRoot":""}